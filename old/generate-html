#!/usr/local/bin/perl

BEGIN { unshift(@INC, "lib");}

use XML::API::NCX;
use XML::API::XHTML11;

use Getopt::Long;
use YAML::Syck;
use File::Slurp;
use UUID::Tiny qw(:std);
use File::Spec;
use HTML::Entities;

use lib ".";
use BookLib;

# Locally defined XML::API outputs
import XML::API::NCX;
import XML::API::XHTML11;

#use strict;

use vars qw(
  %argv $c $u $wikidir $cachedir $htmldir $epubfile $templatedir );

# $toc = read_file( "$wikidir/BetterToC.md", { binmode => ':utf8'} );
#
# (@mentioned) = wiki_links($toc);
# %mentioned = map { $_ => 1 } @mentioned;

main();

sub main {
    $DB::single = 1;

    init();
    book_open();
    book_write_pages();
#    book_write_toc();
#    book_write_meta();
#    book_finalize();
}

sub init {
    %argv = get_options();
    $c    = LoadFile( $argv{"c"} );
    $u    = LoadFile( $argv{"u"} );

    chdir( $c->{paths}{top} ) or die "could not chdir $c->{paths}{top}";

    $wikidir     = $c->{paths}{wiki};
    $htmldir     = $c->{paths}{html};
    $cachedir = $c->{paths}{cache};
    $epubfile     = $c->{paths}{epub};
    $templatedir = $c->{paths}{template};

}

sub book_open {
    book_cleanup($htmldir,$epubfile);
    system( "rsync", "-a", "$templatedir/.", "$htmldir/." );
}

sub book_cleanup {
    my($htmldir,$epubfile) = @_;
    if ( !$htmldir ) {
        die "book_cleanup() called without a dir name";
    } elsif ( -d $htmldir ) {
        die "dir $htmldir is not a book directory, refusing to continue" unless ( -f "$htmldir/mimetype" );
    } elsif ( -f $htmldir ) {
        die "file $htmldir specified as the book directory; but is a plain file instead, refusing to continue";
    }
    die "bad and possibly dangerous dir name $htmldir, refusing to clean it" if ( $htmldir =~ m#^(.*/)?\.# );
    my @glob = glob("$htmldir/*");
    if (@glob) {
        system( "rm", "-fr", "$htmldir" );
    }
    system( "mkdir", "-p", $htmldir );
    die "Could not mkdir -p $htmldir: $!" unless ( -d $htmldir );
    unlink($epubfile);
}


# Find all the pages.
# Write all the pages.
sub book_write_pages {
  my @files = read_dir($wikidir);
  my @names = map(substr($_,0,-3), grep(/\.md$/,@files));
  book_write_one_page($_) foreach (@names);
}

sub book_write_one_page {
    my ($name) = @_;

    # Inputs
    # $wikidir/$name.md
    # $cachedir/$anme.html
    #
    # Outputs
    # $htmldir/$name.html

breakpoint();
$DB::single=1;
    my $md    = read_file("$wikidir/$name.md");
    my $cache = read_file("$cachedir/$name.html");
    my $title = get_title_from_md($md) || $name;

    my $x = new XML::API::XHTML11( encoding => "UTF-8" );
    $x->html_open();
    $x->head_open();
    $x->title($title);
    $x->link( { type => "text/css", rel => "stylesheet", href => "index.css" } );
    $x->head_close();
    $x->body_open();

    $x->_raw($cache);
    $x->body_close();
    $x->html_close();

    write_file( "$htmldir/$name.html", $title, $x );
} ## end sub book_write_one_page


sub book_write_toc {

    my $x = new XML::API::XHTML11( encoding => "UTF-8" );
    my $title = "Table of Contents";

    $x->html_open();
    $x->head_open();
    $x->title($title);
    $x->link( { type => "text/css", rel => "stylesheet", href => "index.css" } );
    $x->head_close();

    $x->body_open();
    $x->div_open( -id => 'content' );

#    $x->h1($title);

    my $toc = new XML::API;
    $toc->ul_open;
    $toc->li_open;
    $toc->a( { href => "#ord" }, "Jump to the Ordinary TOC" );
    $toc->li_close;
    $toc->li_open;
    $toc->a( { href => "#arm" }, "Jump to the Armorial TOC" );
    $toc->li_close;
    $toc->ul_close;

    $x->_add($toc) if ( $flag_armorial && $flag_ordinary );

    #TODO links to the Ordinary TOC vs the Amorial TOC
    if ($flag_ordinary) {
        $x->h2( { id => "ord" }, "Ordinary Table of Contents" );
        $x->_add($toc) if ( $flag_armorial && $flag_ordinary );

        foreach my $page ( sort keys %ord_plan_by_page ) {
            my $title = $pagetitle{$page};
            $x->div_open( { class => "index" } );
            $x->a( { href => $page }, $title );
            $x->div_close;
        }
    }
    if ($flag_armorial) {

        $x->h2( { id => "arm" }, "Armorial Table of Contents" );
        $x->_add($toc) if ( $flag_armorial && $flag_ordinary );

        foreach my $page ( sort keys %arm_plan_by_page ) {
            my $title = $pagetitle{$page};
            $x->div_open( { class => "index" } );
            $x->a( { href => $page }, $title );
            $x->div_close;
        }
    }
    $x->div_close();    # id=content
    $x->body_close();
    $x->html_close();
    return book_save_html( "toc.html", $title, $x );
} ## end sub book_write_toc

sub book_write_meta {

    my $opf = new XML::API::XHTML11( encoding => "UTF-8" );

    $opf->package_open(
        {

            "xmlns"             => "http://www.idpf.org/2007/opf",
            "xmlns:dc"          => "http://purl.org/dc/elements/1.1/",
            "unique-identifier" => "bookid",
            "version"           => "2.0"
        }
    );

    my $uuid     = create_uuid_as_string(UUID_RANDOM);
    my $metadata = new XML::API;                         # opf
    $metadata->metadata_open( {} );
    $metadata->dc__title($booktitle);
    $metadata->dc__creator($bookcreator);
    $metadata->dc__source($booksource);
    $metadata->dc__rights($bookrights);
    $metadata->dc__identifier( { id => "bookid" }, $uuid );    # TODO Make this vary on MD5 of input (or random?)
    $metadata->dc__language("en-US");
    $metadata->meta( { name => "cover", content => "cover-image" } );

    my $manifest = new XML::API;                               #opf
    $manifest->manifest_open();
    $manifest->item( { "id" => "ncx",         "href" => "toc.ncx",     "media-type" => "application/x-dtbncx+xml" } );
    $manifest->item( { "id" => "cover-image", "href" => "cover.png",   "media-type" => "image/png" } );
    $manifest->item( { "id" => "css",         "href" => "index.css",   "media-type" => "text/css" } );
    $manifest->item( { "id" => "cover",       "href" => "cover.html",  "media-type" => "application/xhtml+xml" } );
    $manifest->item( { "id" => "notice",      "href" => "notice.html", "media-type" => "application/xhtml+xml" } );
    $manifest->item( { "id" => "toc",         "href" => "toc.html",    "media-type" => "application/xhtml+xml" } );

    my $spine = new XML::API;                                  # opf
    $spine->spine_open( { toc => "ncx" } );
    $spine->itemref( { "idref" => "cover" } );                 # , "linear"=>"no"
    $spine->itemref( { "idref" => "notice" } );                # , "linear"=>"no"
    $spine->itemref( { "idref" => "toc" } );

    my $guide = new XML::API;                                  # opf
    $guide->guide_open();
    $guide->reference( { href => "cover.html",  type => "cover",          title => "Cover" } );
    $guide->reference( { href => "notice.html", type => "copyright-page", title => "Copyright" } );
    $guide->reference( { href => "toc.html",    type => "toc",            title => "Table of Contents" } );

    my $navmap         = new XML::API;                         # ncx
    my $navmap_counter = 1;
    $navmap->navMap_open();
    $navmap->_add( navpoint( $navmap_counter++, "Book cover",        "cover.html" ) );
    $navmap->_add( navpoint( $navmap_counter++, "Notice",            "notice.html" ) );
    $navmap->_add( navpoint( $navmap_counter++, "Table of Contents", "toc.html" ) );      # Trying to get this to show up despite the iPad wanting to take ownership for it

    my @pages;
    push( @pages, sort keys %ord_plan_by_page ) if ($flag_ordinary);
    push( @pages, sort keys %arm_plan_by_page ) if ($flag_armorial);
    foreach my $page (@pages) {
        my ($id) = split( /\./, $page );
        $manifest->item( { "id" => $id, "href" => $page, "media-type" => "application/xhtml+xml" } );
        $spine->itemref( { idref => $id } );
        $guide->reference( { href => $page, type => "text", title => $pagetitle{$page} } );
        $navmap->_add( navpoint( $navmap_counter++, $pagetitle{$page}, $page ) );
    }

    $metadata->metadata_close();
    $manifest->manifest_close();
    $spine->spine_close();
    $guide->guide_close();
    $navmap->navMap_close();

    $opf->_add( $metadata, $manifest, $spine, $guide );
    $opf->package_close();
    book_save_html( "content.opf", "content.opf", $opf );

    my $ncx = new XML::API::NCX( encoding => "UTF-8" );
    $ncx->ncx_open( { xmlns => "http://www.daisy.org/z3986/2005/ncx/", version => "2005-1" } );
    $ncx->head_open();
    $ncx->meta( { name => "dtb:uid",            content => $uuid } );
    $ncx->meta( { name => "dtb:depth",          content => "1" } );
    $ncx->meta( { name => "dtb:totalPageCount", content => "0" } );
    $ncx->meta( { name => "dtb:maxPageNumber",  content => "0" } );
    $ncx->head_close();

    $ncx->docTitle_open();
    $ncx->text($booktitle);
    $ncx->docTitle_close();
    $ncx->_add($navmap);    # Generated somewhere up above

    $ncx->ncx_close();

#    breakpoint();
    book_save_html( "toc.ncx", "toc.ncx", $ncx );

} ## end sub book_write_meta

sub navpoint {
    my ( $counter, $text, $src ) = @_;
    my $x = new XML::API;
    $x->navPoint_open( { id => "navpoint-$counter", playOrder => $counter } );
    $x->navLabel_open();
    $x->text($text);
    $x->navLabel_close();
    $x->content( { src => $src } );
    $x->navPoint_close();
    return $x;
}

sub book_finalize {
    my $epub = $bookname . ".epub";

    my $abspath = File::Spec->rel2abs($epub);
    die "failed to get abspath for $epub (unexpected error)" unless ($abspath);    # Not expected

    unlink($abspath);
    system("cd $bookname && zip -v0Xq $abspath mimetype && zip -vXr9Dq $abspath *");
    system( "ls", "-l", $abspath );

}



our %skip;

sub breakpoint_dump {
    if (@_) {
        $Data::Dumper::Terse = 1;
        local $Data::Dumper::Sortkeys = 1;
        print Dumper(@_);
    }
}

sub breakpoint {

    # If we are operating a debugger, let us be a lot more verbose.
    if ( defined &DB::DB ) {
        my ( undef, undef, undef, $subroutine ) = caller(1);    # To get the right "subroutine" name
        my ( $package, $filename, $line ) = caller(0);          # To get the right filename and line number
        return if ( exists $skip{"$filename\:$line"} );
        breakpoint_dump(@_);
        print STDERR
          "breakpoint() called from $filename\:$line (sub $subroutine); set \$skip{'$filename\:$line'}=1 to stop breaking here.\n";
    }

    # Invoke the debugger after we return from breakpoint().
    no warnings;
}

